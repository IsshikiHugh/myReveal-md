<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/IroBright.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Lab3: Safe Fruit</h2>
					<hr />
					<h3>Group 8</h3>
				</section>
				<section>
					<section>
						<h2>Problem</h2>
						<p class="fragment fade-in-then-semi-out">
							Some fruits must not be eaten with some other fruits.
						</p>
						<p class="fragment fade-in-then-semi-out">
							Pick up maximum number of fruits that can be eat safely.
						</p>
					</section>
					<section>
						<h2>Abstraction</h2>
						<p class="fragment fade-in-then-semi-out">
							Insert as many $x$ as possible into a set $U$.
						</p>
						<p class="fragment fade-in-then-semi-out">
							For each $x$, no $y \in U$ has conflicts with $x$.
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Baseline</h2>
						<h3>Naive Backtracking</h3>
					</section>
					<section>
						<h2>
							Content
						</h2>
						<p class="fragment fade-in-then-semi-out">
							Use dfs to search all possible solutions.
						</p>
						<p class="fragment fade-in-then-semi-out">
							Check if current $x$ is ok to insert, rather than check in the end.
						</p>
						<p class="fragment fade-in-then-semi-out">
							To reduce the number of recursive layers, we use loop to find next possible $x$.
						</p>
						<p class="fragment fade-in-then-semi-out">
							And a basic pruning method is used. If the rest of the fruits can not fill the gap, we can stop searching.
						</p>
					</section>
					<section>
						<h2>
							Pesudo Code
						</h2>
						<img data-src="pseudo1.png" width = 70%>
					</section>
				</section>
				<section>
					<section>
						<h2>Improvement</h2>
						<h3>Mnemonization Optimized</h3>
					</section>
					<section>
						<h2>
							Content
						</h2>
						<p class="fragment fade-in-then-semi-out">
							Still use dfs to search all possible solutions.
						</p>
						<p class="fragment fade-in-then-semi-out">
							What's different is that we use a memory search to reduce the number of recursive layers.
						</p>
						<p class="fragment fade-in-then-semi-out">
							We can imagine the <b>repetitive</b> work delaying efficiency.
						</p>
						<p class="fragment fade-in-then-semi-out">
							So use something to <b>memorize</b> it!
						</p>
						<p class="fragment fade-in-then-semi-out">
							Rather then dfs only the max situation, we dfs from the min situation and memorize the result.
						</p>
						<p class="fragment fade-in-then-semi-out">
							It's a bit like dp:
							\[
							dp_i = \left\{
								\begin{aligned}
									& dp_{i+1} + 1 \\
									& dfs(i, dp_i)
								\end{aligned}
							\right.
							\text{  where  } i \text{ from n to 1 }
							\]
						</p>
					</section>
					<section>
						Naive Pruning: \[tmp.size()+fruits.size()-i< res.size()\]
					</section>
					<section>
						Memory Search: \[tmp.size()+cnt[i+1]+1< res.size()\] \[tmp.size()+fruits.size()-i< res.size()\]
					</section>
					<section>
						<h2>
							Pesudo Code (P1)
						</h2>
						<img data-src="pseudo2.png" width = 70%>
					</section>
					<section>
						<h2>
							Pesudo Code (P2)
						</h2>
						<img data-src="pseudo3.png" width = 70%>
					</section>
				</section>
				<section>
					<section>
						<h2>Fail Try</h2>
						<h3>Spare Step</h3>
					</section>
					<section>
						<h2>
							Content
						</h2>
						<p class="fragment fade-in-then-semi-out">
							Although memorization boost the efficiency, but I notice more basic dp caused by the pretreatment.
						</p>
						<p class="fragment fade-in-then-semi-out">
							But the limits from the previous situation's result shouldn't be an exact number.
						</p>
						<p class="fragment fade-in-then-semi-out">
							So why not update it in a more spare way?
						</p>
						<p class="fragment fade-in-then-semi-out">
							That means, the limits become a upper bound, rather then an exact number.
						</p>
					</section>
					<section>
						<h2>
							Override

							<img src="code1.png">
						</h2>
					</section>
					<section>
						<h2>Performance</h2>
						<table>
							<tr>
								<td>Scale</td>
								<td>Naive</td>
								<td>Memorize</td>
								<td>Sparse 2</td>
								<td>Sparse 3</td>
								<td>Sparse 5</td>
								<td>Linear</td>
								<td>Square</td>
							</tr>
							<tr>
								<td>N=16, M=32</td>
								<td>4.663s</td>
								<td>4.156s</td>
								<td>4.140s</td>
								<td>4.124s</td>
								<td>4.124s</td>
								<td>4.118s</td>
								<td>4.121s</td>
							</tr>
							<tr>
								<td>N=32, M=32</td>
								<td>4.432s</td>
								<td>3.870s</td>
								<td>3.849s</td>
								<td>3.843s</td>
								<td>3.842s</td>
								<td>3.832s</td>
								<td>3.823s</td>
							</tr>
							<tr>
								<td>N=48, M=32</td>
								<td>4.664s</td>
								<td>4.187s</td>
								<td>4.168s</td>
								<td>4.166s</td>
								<td>4.163s</td>
								<td>4.161s</td>
								<td>4.161s</td>
							</tr>
						</table>
						<p>On maxOS 12.6 Apple M1, each for 1000 cases</p>
					</section>
					
				</section>
				<section>
					<h2>Time Complexity</h2>
					According to Power Set Theorem,
					Backtracking without pruning: \[O(N^2\cdot 2^{M})\]
				</section>
				<section>
					<section>
						<h2>Space Complexity</h2>
						<p>If we adopt a mapping like map, implemented by a red-black tree, the space complexity is \[O(M \log M)\]</p>
					</section>
					<section>
						<p>If we adopt a mapping like unordered_map, implemented by a hash table, the space complexity is \[O(H)\] where H is the size of the hash table. And we use a simple hash function \[f(u, v) = u \times {\tt LIM} + v\] \[H = {\tt LIM} = 2048\]</p>
					</section>
				</section>
				<section>
					<h1>TK4L!</h1>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize(
				{
					hash: true,

					// Hightlight
					highlight: {
						beforeHighlight: hljs => hljs.registerLanguage("cpp")
					},

					// Math
					math: {
						mathjax:
							"https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js",
						config: "TeX-AMS_HTML-full",
						// pass other options into `MathJax.Hub.Config()`
						TeX: { Macros: { RR: "{\\bf R}" } },
					},

					// Learn about plugins: https://revealjs.com/plugins/
					plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath ]
				}
			);
		</script>
		<script src="plugin/math/math.js"></script>
		<script>
		  Reveal.initialize({ plugins: [ RevealMath.KaTeX ] });
		</script>
	</body>
</html>
